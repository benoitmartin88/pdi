! *******************************************************************************
! * Copyright (C) 2016, Julien Bigot - CEA (julien.bigot@cea.fr)
! * Copyright (C) 2016, Mohamed Gaalich - CEA (mohamed.gaalich@cea.fr)
! * All rights reserved.
! *
! * Redistribution and use in source and binary forms, with or without
! * modification, are permitted provided that the following conditions are met:
! * * Redistributions of source code must retain the above copyright
! *   notice, this list of conditions and the following disclaimer.
! * * Redistributions in binary form must reproduce the above copyright
! *   notice, this list of conditions and the following disclaimer in the
! *   documentation and/or other materials provided with the distribution.
! * * Neither the name of CEA nor the names of its contributors may be used to
! *   endorse or promote products derived from this software without specific
! *   prior written permission.
! *
! * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
! * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
! * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
! * THE SOFTWARE.
! ******************************************************************************

!$SH source fortran.bpp.sh
!$SH MAXDIM=7

module PDI

  use ISO_C_binding
  use paraconf

  implicit none
  
  interface
  
    function PDI_init_f_C(treeconf, world) bind(C, name="PDI_init_f")
      use ISO_C_binding
      use paraconf
      integer(C_int) :: PDI_init_f_C
      type(PC_tree_t), value :: treeconf
      integer, intent(INOUT):: world
    endfunction PDI_init_f_C
    
    function PDI_finalize_C() bind(C, name="PDI_finalize")
      use ISO_C_binding
      integer(C_int) :: PDI_finalize_C
    endfunction PDI_finalize_C
    
    function PDI_event_C(event) bind(C, name="PDI_event")
      use ISO_C_binding
      integer(C_int) :: PDI_event_C
      type(C_ptr), value :: event
    endfunction PDI_event_C
    
    function PDI_share_C(name, data, accessf) bind(C, name="PDI_share")
      use ISO_C_binding
      integer(C_int) :: PDI_share_C
      type(C_ptr), value :: name
      type(C_ptr), value :: data
      integer(C_int), value :: accessf
    endfunction PDI_share_C
    
    function PDI_release_C(name) bind(C, name="PDI_release")
      use ISO_C_binding
      integer(C_int) :: PDI_release_C
      type(C_ptr), value :: name
    endfunction PDI_release_C
    
    function PDI_reclaim_C(name) bind(C, name="PDI_reclaim")
      use ISO_C_binding
      integer(C_int) :: PDI_reclaim_C
      type(C_ptr), value :: name
    endfunction PDI_reclaim_C
    
    function PDI_export_C(name, data) bind(C, name="PDI_export")
      use ISO_C_binding
      integer(C_int) :: PDI_export_C
      type(C_ptr), value :: name
      type(C_ptr), value :: data
    endfunction PDI_export_C
    
    function PDI_expose_C(name, data) bind(C, name="PDI_expose")
      use ISO_C_binding
      integer(C_int) :: PDI_expose_C
      type(C_ptr), value :: name
      type(C_ptr), value :: data
    endfunction PDI_expose_C
    
    function PDI_import_C(name, data) bind(C, name="PDI_import")
      use ISO_C_binding
      integer(C_int) :: PDI_import_C
      type(C_ptr), value :: name
      type(C_ptr), value :: data
    endfunction PDI_import_C
    
    function PDI_transaction_begin_C( name ) bind(C, name="PDI_transaction_begin")
      use ISO_C_binding
      integer(C_int) :: PDI_transaction_begin_C
      type(C_ptr), value :: name
    endfunction PDI_transaction_begin_C
    
    function PDI_transaction_end_C() bind(C, name="PDI_transaction_end")
      use ISO_C_binding
      integer(C_int) :: PDI_transaction_end_C
    endfunction PDI_transaction_end_C
    
  endinterface

  

!$SH if [ -n "${NO_CLOC_ARRAY}" ]; then
  interface fptr
!$SH for T in ${FORTTYPES}; do
!$SH   for D in $(seq 0 ${MAXDIM}); do
    module procedure fptr_${T}_${D}D
!$SH   done
!$SH done
  endinterface fptr
!$SH fi

  

  interface PDI_share
!$SH for T in ${FORTTYPES}; do
!$SH   for D in $(seq 0 ${MAXDIM}); do
    module procedure PDI_share_${T}_${D}D
!$SH   done
!$SH done
  endinterface PDI_share

  
  
  interface PDI_export
!$SH for T in ${FORTTYPES}; do
!$SH   for D in $(seq 0 ${MAXDIM}); do
    module procedure PDI_export_${T}_${D}D
!$SH   done
!$SH done
  endinterface PDI_export

  
  
  interface PDI_expose
!$SH for T in ${FORTTYPES}; do
!$SH   for D in $(seq 0 ${MAXDIM}); do
    module procedure PDI_expose_${T}_${D}D
!$SH   done
!$SH done
  endinterface PDI_expose

  
  
  interface PDI_import
!$SH for T in ${FORTTYPES}; do
!$SH   for D in $(seq 0 ${MAXDIM}); do
    module procedure PDI_import_${T}_${D}D
!$SH   done
!$SH done
  endinterface PDI_import


  contains

!$SH if [ -n "${NO_CLOC_ARRAY}" ]; then
!$SH for T in ${FORTTYPES}; do
!$SH   for D in $(seq 0 ${MAXDIM}); do

  pure function fptr_${T}_${D}D ( data ) result ( pdata )
    $(fort_type $T), intent(IN), target :: data$(array_desc $D)
    $(fort_type $T), target :: pdata
    pdata = data$(str_repeat 'lbound(data, @N)' 1 ${D} $',&\n ' '(' ')')
  end function fptr_${T}_${D}D

!$SH   done
!$SH done
!$SH fi
  
  !=============================================================================
  !< interface to the C function PDI_init : initializes PDI
  !! \param[IN] treeconf the configuration
  !! \param[IN,OUT] world the main mpi communicator
  !! \param[OUT] err for error status (optional)
  subroutine PDI_init(treeconf, world, err)
    type(PC_tree_t), intent(IN) :: treeconf
    integer, intent(INOUT), target :: world
    integer, intent(OUT), optional :: err

    integer(C_int) :: tmpcerr
    
    tmpcerr=PDI_init_f_C(treeconf, world)
    
    if(present(err)) then
      err = int(tmpcerr)
    endif

    
  endsubroutine PDI_init
  !=============================================================================
  
  
  
  !=============================================================================
  !< interface to the C function PDI_finalize : finalizes PDI
  !! \param[OUT] err for error status (optional)
  subroutine PDI_finalize(err)
    integer, intent(OUT), optional :: err

    integer :: tmperr

    tmperr = int(PDI_finalize_C())
    
    if(present(err)) then
      err = tmperr
    endif
    
  endsubroutine PDI_finalize
  !=============================================================================
  
  
  
  !=============================================================================
  !< interface to the C function PDI_event : triggers a PDI “event”
  !! \param[IN] event the event name
  !! \param[OUT] err for error status (optional)
  subroutine PDI_event(event, err)
    character(len=*), intent(IN) :: event
    integer, intent(OUT), optional :: err

    character(C_char), target :: C_event(len_trim(event)+1)
    integer :: ii, tmperr

    do ii=1, len_trim(event)
      C_event(ii) = event(ii:ii)
    enddo
    C_event(len_trim(event)+1) = C_null_char

    tmperr = int(PDI_event_C(C_loc(C_event)))
    
    if(present(err)) then
      err = tmperr
    endif
    
  endsubroutine PDI_event
  !=============================================================================
  
  
!$SH for T in ${FORTTYPES}; do
!$SH   for D in $(seq 0 ${MAXDIM}); do
  
  !=============================================================================
  !< interface to the C function PDI_share :
  !! shares some data with PDI. the user code should not modify it before
  !! a call to either PDI_release or PDI_reclaim.
  !! \param[IN] name the data name
  !! \param[IN,OUT] data the accessed data
  !! \param[IN] accessf whether the data can be accessed for read or write by
  !!            PDI
  !! \param[OUT] err for error status (optional)
  !! \pre the user code owns the data buffer
  !! \post ownership of the data buffer is shared between PDI and the user code
  !!
  !! the access parameter is a binary or of PDI_IN & PDI_OUT.
  !! * PDI_IN means PDI can set the buffer content
  !! * PDI_OUT means the buffer contains data that can be accessed by PDI
  subroutine PDI_share_${T}_${D}D( name, data, accessf, err )
    character(len=*), intent(IN) :: name
    $(fort_type $T), intent(INOUT), target :: data$(array_desc $D)
    integer, intent(IN) :: accessf
    integer, intent(OUT), optional :: err

    character(C_char), target :: C_name(len_trim(name)+1)
    integer :: ii, tmperr

    do ii=1, len_trim(name)
      C_name(ii) = name(ii:ii)
    enddo
    C_name(len_trim(name)+1) = C_null_char
    
!$SH if [ -n "${NO_CLOC_ARRAY}" ]; then
    tmperr = int(PDI_share_C(C_loc(C_name), &
        C_loc(fptr(data)), &
        accessf))
!$SH else
    tmperr = int(PDI_share_C(C_loc(C_name), &
        C_loc(data$(str_repeat 'lbound(data, @N)' 1 ${D} $',&\n ' '(' ')')), &
        accessf))
!$SH fi
    
    if(present(err)) then
      err = tmperr
    endif
    
  endsubroutine PDI_share_${T}_${D}D
  !=============================================================================
  
  
!$SH   done
!$SH done
  
  !=============================================================================
  !< interface to the C function PDI_release :
  !! releases ownership of a data shared with PDI. PDI is then responsible to
  !! free the associated memory whenever necessary.
  !! \param[IN] name name of the data to release
  !! \param[OUT] err for error status (optional)
  !! \pre ownership of the data buffer is shared between PDI and the user code
  !! \pre PDI owns the data buffer
  subroutine PDI_release(name, err)
    character(len=*), intent(IN) :: name
    integer, intent(OUT), optional :: err

    character(C_char), target :: C_name(len_trim(name)+1)
    integer :: ii, tmperr

    do ii=1, len_trim(name)
      C_name(ii) = name(ii:ii)
    enddo
    C_name(len_trim(name)+1) = C_null_char

    tmperr = int(PDI_release_C(C_loc(C_name)))
    
    if(present(err)) then
      err = tmperr
    endif
    
  endsubroutine PDI_release
  !=============================================================================
  
  
  
  !=============================================================================
   !< interface to the C function PDI_reclaim :
   !! reclaims ownership of a data buffer shared with PDI. PDI is then
   !! responsible to free the associated memory whenever necessary.
   !! \param[IN] name name of the data to reclaim
   !! \param[OUT] err for error status (optional)
   !! \pre ownership of the data buffer is shared between PDI and the user code
   !! \post the user code owns the data buffer
  subroutine PDI_reclaim(name, err)
    character(len=*), intent(IN) :: name
    integer, intent(OUT), optional :: err

    character(C_char), target :: C_name(len_trim(name)+1)
    integer :: ii, tmperr

    do ii=1, len_trim(name)
      C_name(ii) = name(ii:ii)
    enddo
    C_name(len_trim(name)+1) = C_null_char

    tmperr = int(PDI_reclaim_C(C_loc(C_name)))
    
    if(present(err)) then
      err = tmperr
    endif
    
  endsubroutine PDI_reclaim
  !=============================================================================
  
  
!$SH for T in ${FORTTYPES}; do
!$SH   for D in $(seq 0 ${MAXDIM}); do
  
  !=============================================================================
  !< interface to the C function PDI_export :
  !! exports some data to PDI. equivalent to PDI_share(OUT) + PDI_release.
  !! \param[IN] name the data name
  !! \param[IN] data the exported data
  !! \param[OUT] err for error status (optional)
  subroutine PDI_export_${T}_${D}D(name, data, err)
    character(len=*), intent(IN) :: name
    $(fort_type $T), intent(IN), target :: data$(array_desc $D)
    integer, intent(OUT), optional :: err

    character(C_char), target :: C_name(len_trim(name)+1)
    integer :: ii, tmperr

    do ii=1, len_trim(name)
      C_name(ii) = name(ii:ii)
    enddo
    C_name(len_trim(name)+1) = C_null_char

!$SH if [ -n "${NO_CLOC_ARRAY}" ]; then
    tmperr = int(PDI_export_C(C_loc(C_name), &
        C_loc(fptr(data))))
!$SH else
    tmperr = int(PDI_export_C(C_loc(C_name), &
        C_loc(data$(str_repeat 'lbound(data, @N)' 1 ${D} $',&\n ' '(' ')'))))
!$SH fi

    if(present(err)) then
      err = tmperr
    endif
    
  endsubroutine PDI_export_${T}_${D}D
  !=============================================================================
  
!$SH   done
!$SH done
!$SH for T in ${FORTTYPES}; do
!$SH   for D in $(seq 0 ${MAXDIM}); do
  
  
  !=============================================================================
  !< interface to the C function PDI_expose :
  !! shortly exposes some data to PDI. equivalent to PDI_share(OUT) + PDI_reclaim.
  !! \param[IN] name the data name
  !! \param[IN] data the exposed data
  !! \param[OUT] err for error status (optional)
  subroutine PDI_expose_${T}_${D}D(name, data, err)
    character(len=*), intent(IN) :: name
    $(fort_type $T), intent(IN), target :: data$(array_desc $D)
    integer, intent(OUT), optional :: err

    character(C_char), target :: C_name(len_trim(name)+1)
    integer :: ii, tmperr

    do ii=1, len_trim(name)
      C_name(ii) = name(ii:ii)
    enddo
    C_name(len_trim(name)+1) = C_null_char

!$SH if [ -n "${NO_CLOC_ARRAY}" ]; then
    tmperr = int(PDI_expose_C(C_loc(C_name), &
        C_loc(fptr(data))))
!$SH else
    tmperr = int(PDI_expose_C(C_loc(C_name), &
        C_loc(data$(str_repeat 'lbound(data, @N)' 1 ${D} $',&\n ' '(' ')'))))
!$SH fi
    
    if(present(err)) then
      err = tmperr
    endif
    
  endsubroutine PDI_expose_${T}_${D}D
  !=============================================================================
  
!$SH   done
!$SH done
!$SH for T in ${FORTTYPES}; do
!$SH   for D in $(seq 0 ${MAXDIM}); do
  
  
  !=============================================================================
  !< interface to the C function PDI_import :
  !! imports some data from PDI. equivalent to PDI_share(IN) + PDI_reclaim.
  !! \param[IN] name the data name
  !! \param[OUT] data the data to initialize
  !! \param[OUT] err for error status (optional)
  subroutine PDI_import_${T}_${D}D(name, data, err)
    character(len=*), intent(IN) :: name
    $(fort_type $T), intent(OUT), target :: data$(array_desc $D)
    integer, intent(OUT), optional :: err

    character(C_char), target :: C_name(len_trim(name)+1)
    integer :: ii, tmperr

    do ii=1, len_trim(name)
      C_name(ii) = name(ii:ii)
    enddo
    C_name(len_trim(name)+1) = C_null_char

!$SH if [ -n "${NO_CLOC_ARRAY}" ]; then
    tmperr = int(PDI_import_C(C_loc(C_name), &
        C_loc(fptr(data))))
!$SH else
    tmperr = int(PDI_import_C(C_loc(C_name), &
        C_loc(data$(str_repeat 'lbound(data, @N)' 1 ${D} $',&\n ' '(' ')'))))
!$SH fi
    if(present(err)) then
      err = tmperr
    endif
    
  endsubroutine PDI_import_${T}_${D}D
  !=============================================================================
  
!$SH   done
!$SH done
  
  !=============================================================================
  !< Begin a transaction. All the ::PDI_expose will be exposed together.
  !! 
  !! This requires a ::PDI_transaction_end to close the transaction.
  !! 
  !! \param[in] name the name of the transaction (an event thus named will be
  !!                 triggered when all data become available)
  !! \param[out] err an error status
  subroutine PDI_transaction_begin( name, err )
    character(len=*), intent(IN) :: name
    integer, intent(OUT), optional :: err

    character(C_char), target :: C_name(len_trim(name)+1)
    integer :: ii, tmperr

    do ii=1, len_trim(name)
      C_name(ii) = name(ii:ii)
    enddo
    C_name(len_trim(name)+1) = C_null_char

    tmperr = int(PDI_transaction_begin_C(C_loc(C_name)))
    
    if(present(err)) then
      err = tmperr
    endif
    
  endsubroutine PDI_transaction_begin
  !=============================================================================
  
  
  !=============================================================================
  !< Ends the previously opened transaction.
  !! \param[out] err an error status
  subroutine PDI_transaction_end( err )
    integer, intent(OUT), optional :: err

    integer :: tmperr

    tmperr = int(PDI_transaction_end_C())
    
    if(present(err)) then
      err = tmperr
    endif
    
  endsubroutine PDI_transaction_end
  !=============================================================================
  
endmodule PDI
